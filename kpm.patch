diff --git a/include/linux/set_memory.h b/include/linux/set_memory.h
index XXXXXXX..XXXXXXX 100644
--- a/include/linux/set_memory.h
+++ b/include/linux/set_memory.h
@@ -1,10 +1,19 @@
 #ifndef __LINUX_SET_MEMORY_H
 #define __LINUX_SET_MEMORY_H
 
 #include <linux/mm.h>
+#include <linux/types.h>
 
+#ifdef CONFIG_ARCH_HAS_SET_MEMORY
 int set_memory_ro(unsigned long addr, int numpages);
 int set_memory_rw(unsigned long addr, int numpages);
 int set_memory_x(unsigned long addr, int numpages);
 int set_memory_nx(unsigned long addr, int numpages);
+int set_memory_valid(unsigned long addr, int numpages, int enable);
+#else
+static inline int set_memory_ro(unsigned long addr, int numpages) { return 0; }
+static inline int set_memory_rw(unsigned long addr, int numpages) { return 0; }
+static inline int set_memory_x(unsigned long addr, int numpages) { return 0; }
+static inline int set_memory_nx(unsigned long addr, int numpages) { return 0; }
+static inline int set_memory_valid(unsigned long addr, int numpages, int enable) { return 0; }
+#endif /* CONFIG_ARCH_HAS_SET_MEMORY */
 #endif /* __LINUX_SET_MEMORY_H */
diff --git a/mm/pageattr.c b/mm/pageattr.c
index XXXXXXX..XXXXXXX 100644
--- a/mm/pageattr.c
+++ b/mm/pageattr.c
@@ -1,5 +1,6 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/set_memory.h>
 #include <linux/vmalloc.h>
 #include <asm/tlbflush.h>
 #include <asm/page.h>
@@ -10,6 +11,45 @@
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 
+#ifdef CONFIG_ARCH_HAS_SET_MEMORY
+
+static int __set_memory_attr(unsigned long addr, int numpages, pgprot_t prot)
+{
+	unsigned long start = addr;
+	unsigned long end = addr + (numpages << PAGE_SHIFT);
+	int ret = 0;
+
+	while (start < end) {
+		struct page *page = virt_to_page((void *)start);
+		if (PageReserved(page)) {
+			ret = -EINVAL;
+			break;
+		}
+		if (change_page_attr(page, 1, prot)) {
+			ret = -EIO;
+			break;
+		}
+		start += PAGE_SIZE;
+	}
+	flush_tlb_all();
+	return ret;
+}
+
+int set_memory_ro(unsigned long addr, int numpages)
+{
+	return __set_memory_attr(addr, numpages, PAGE_KERNEL_RO);
+}
+EXPORT_SYMBOL(set_memory_ro);
+
+int set_memory_rw(unsigned long addr, int numpages)
+{
+	return __set_memory_attr(addr, numpages, PAGE_KERNEL);
+}
+EXPORT_SYMBOL(set_memory_rw);
+
+int set_memory_x(unsigned long addr, int numpages)
+{
+	return __set_memory_attr(addr, numpages, PAGE_KERNEL_EXEC);
+}
+EXPORT_SYMBOL(set_memory_x);
+
+int set_memory_nx(unsigned long addr, int numpages)
+{
+	return __set_memory_attr(addr, numpages, PAGE_KERNEL);
+}
+EXPORT_SYMBOL(set_memory_nx);
+#endif /* CONFIG_ARCH_HAS_SET_MEMORY */
diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c
index XXXXXXX..XXXXXXX 100644
--- a/arch/arm64/mm/pageattr.c
+++ b/arch/arm64/mm/pageattr.c
@@ -1,5 +1,6 @@
 #include <linux/mm.h>
 #include <linux/sched.h>
+#include <linux/set_memory.h>
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/mmu.h>
@@ -20,6 +21,22 @@
 #include <asm/tlb.h>
 #include <asm/hugetlb.h>
 
+pgprot_t pgprot_ro(pgprot_t prot)
+{
+	return __pgprot(pgprot_val(prot) & ~PTE_WRITE);
+}
+
+pgprot_t pgprot_rw(pgprot_t prot)
+{
+	return __pgprot(pgprot_val(prot) | PTE_WRITE);
+}
+
+pgprot_t pgprot_exec(pgprot_t prot)
+{
+	return __pgprot(pgprot_val(prot) | PTE_EXEC);
+}
+
+pgprot_t pgprot_nx(pgprot_t prot)
+{
+	return __pgprot(pgprot_val(prot) & ~PTE_EXEC);
+}
diff --git a/arch/arm64/configs/defconfig b/arch/arm64/configs/defconfig
index XXXXXXX..XXXXXXX 100644
--- a/arch/arm64/configs/defconfig
+++ b/arch/arm64/configs/defconfig
@@ -500,6 +500,8 @@ CONFIG_KALLSYMS=y
 CONFIG_KALLSYMS_ALL=y
 CONFIG_PRINTK=y
 CONFIG_BUG=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_KPM=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
diff --git a/kernel/Kconfig b/kernel/Kconfig
index XXXXXXX..XXXXXXX 100644
--- a/kernel/Kconfig
+++ b/kernel/Kconfig
@@ -1822,6 +1822,14 @@ config CRASH_DUMP
 	  to save the kernel memory for later analysis. This is useful for
 	  debugging kernel crashes.
 
+config KPM
+	tristate "KernelPatch Module support"
+	depends on KALLSYMS && KALLSYMS_ALL && ARCH_HAS_SET_MEMORY
+	help
+	  Enable support for KernelPatch Module (KPM), which allows dynamic
+	  patching of kernel code at runtime. This requires set_memory.h
+	  support and full kallsyms for symbol resolution.
+
 endmenu
 
 menu "RCU Subsystem"
diff --git a/kernel/Makefile b/kernel/Makefile
index XXXXXXX..XXXXXXX 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_AUDIT) += audit/
 obj-$(CONFIG_KCSAN) += kcsan/
 obj-$(CONFIG_KCOV) += kcov/
 obj-$(CONFIG_KPROBES) += kprobes/
+obj-$(CONFIG_KPM) += kpm/
 obj-$(CONFIG_HAVE_ARCH_TRACEHOOK) += tracehook.o
 obj-$(CONFIG_USER_RETURN_NOTIFIER) += user-return-notifier.o
 obj-$(CONFIG_PADATA) += padata.o
diff --git a/kernel/kpm/kpm.c b/kernel/kpm/kpm.c
new file mode 100644
index 0000000..XXXXXXX
--- /dev/null
+++ b/kernel/kpm/kpm.c
@@ -0,0 +1,312 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/vmalloc.h>
+#include <linux/set_memory.h>
+#include <linux/slab.h>
+#include <linux/elf.h>
+#include <asm/pgtable.h>
+#include "kpm.h"
+
+static LIST_HEAD(kpm_modules);
+static DEFINE_MUTEX(kpm_mutex);
+
+struct kpm_module {
+	struct list_head list;
+	char name[MODULE_NAME_LEN];
+	void *module_addr;
+	size_t module_size;
+	void *reloc_addr;
+	size_t reloc_size;
+};
+
+static int kpm_apply_relocations(void *module_addr, Elf64_Ehdr *ehdr, Elf64_Shdr *shdr)
+{
+	Elf64_Rela *rela;
+	Elf64_Sym *sym;
+	Elf64_Shdr *symtab_shdr, *strtab_shdr, *rela_shdr;
+	unsigned long sym_addr;
+	int i, j;
+
+	for (i = 0; i < ehdr->e_shnum; i++) {
+		if (shdr[i].sh_type != SHT_RELA)
+			continue;
+
+		rela_shdr = &shdr[i];
+		symtab_shdr = &shdr[shdr[i].sh_link];
+		strtab_shdr = &shdr[symtab_shdr->sh_link];
+
+		if (symtab_shdr->sh_type != SHT_SYMTAB ||
+		    strtab_shdr->sh_type != SHT_STRTAB)
+			return -EINVAL;
+
+		rela = (Elf64_Rela *)(module_addr + rela_shdr->sh_offset);
+		for (j = 0; j < rela_shdr->sh_size / rela_shdr->sh_entsize; j++) {
+			Elf64_Addr *addr = (Elf64_Addr *)(module_addr + rela[j].r_offset);
+			unsigned int sym_idx = ELF64_R_SYM(rela[j].r_info);
+
+			sym = (Elf64_Sym *)(module_addr + symtab_shdr->sh_offset +
+					    sym_idx * symtab_shdr->sh_entsize);
+
+			switch (ELF64_R_TYPE(rela[j].r_info)) {
+			case R_AARCH64_ABS64:
+				if (sym->st_shndx == SHN_UNDEF) {
+					sym_addr = (unsigned long)kallsyms_lookup_name(
+						(char *)module_addr + strtab_shdr->sh_offset + sym->st_name);
+					if (!sym_addr)
+						return -ENOENT;
+					*addr = sym_addr + rela[j].r_addend;
+				} else {
+					*addr = (unsigned long)module_addr + sym->st_value + rela[j].r_addend;
+				}
+				break;
+			case R_AARCH64_RELATIVE:
+				*addr = (unsigned long)module_addr + rela[j].r_addend;
+				break;
+			default:
+				pr_err("KPM: Unsupported relocation type %llu\n",
+				       ELF64_R_TYPE(rela[j].r_info));
+				return -EINVAL;
+			}
+		}
+	}
+	return 0;
+}
+
+static int kpm_parse_elf(void *data, size_t size, void **module_addr,
+			size_t *module_size, void **reloc_addr, size_t *reloc_size)
+{
+	Elf64_Ehdr *ehdr = (Elf64_Ehdr *)data;
+	Elf64_Shdr *shdr;
+	void *buf;
+	size_t total_size = 0;
+	int i;
+
+	if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)
+		return -EINVAL;
+
+	if (ehdr->e_ident[EI_CLASS] != ELFCLASS64 ||
+	    ehdr->e_ident[EI_DATA] != ELFDATA2LSB ||
+	    ehdr->e_machine != EM_AARCH64 ||
+	    ehdr->e_type != ET_REL)
+		return -EINVAL;
+
+	shdr = (Elf64_Shdr *)(data + ehdr->e_shoff);
+
+	for (i = 0; i < ehdr->e_shnum; i++) {
+		if (shdr[i].sh_type == SHT_PROGBITS && shdr[i].sh_flags & SHF_EXECINSTR)
+			total_size = max(total_size, shdr[i].sh_offset + shdr[i].sh_size);
+	}
+
+	*module_size = PAGE_ALIGN(total_size);
+	*module_addr = vmalloc(*module_size);
+	if (!*module_addr)
+		return -ENOMEM;
+	memcpy(*module_addr, data, total_size);
+
+	*reloc_size = 0;
+	*reloc_addr = NULL;
+	for (i = 0; i < ehdr->e_shnum; i++) {
+		if (shdr[i].sh_type == SHT_RELA) {
+			*reloc_size += shdr[i].sh_size;
+		}
+	}
+
+	if (*reloc_size) {
+		*reloc_addr = kmalloc(*reloc_size, GFP_KERNEL);
+		if (!*reloc_addr) {
+			vfree(*module_addr);
+			return -ENOMEM;
+		}
+		memcpy(*reloc_addr, data + ehdr->e_shoff, *reloc_size);
+	}
+
+	return kpm_apply_relocations(*module_addr, ehdr, shdr);
+}
+
+int kpm_register(const char *name, void *data, size_t size)
+{
+	struct kpm_module *kpm;
+	int ret;
+
+	if (!name || !data || !size)
+		return -EINVAL;
+
+	kpm = kzalloc(sizeof(*kpm), GFP_KERNEL);
+	if (!kpm)
+		return -ENOMEM;
+
+	strlcpy(kpm->name, name, MODULE_NAME_LEN);
+
+	mutex_lock(&kpm_mutex);
+	ret = kpm_parse_elf(data, size, &kpm->module_addr, &kpm->module_size,
+			   &kpm->reloc_addr, &kpm->reloc_size);
+	if (ret) {
+		kfree(kpm);
+		mutex_unlock(&kpm_mutex);
+		return ret;
+	}
+
+	/* Make text section executable */
+	if (set_memory_x((unsigned long)kpm->module_addr,
+			kpm->module_size >> PAGE_SHIFT)) {
+		pr_err("KPM: Failed to set executable memory\n");
+		vfree(kpm->module_addr);
+		kfree(kpm->reloc_addr);
+		kfree(kpm);
+		mutex_unlock(&kpm_mutex);
+		return -EIO;
+	}
+
+	list_add(&kpm->list, &kpm_modules);
+	mutex_unlock(&kpm_mutex);
+
+	pr_info("KPM: Registered module '%s'\n", name);
+	return 0;
+}
+EXPORT_SYMBOL(kpm_register);
+
+int kpm_unregister(const char *name)
+{
+	struct kpm_module *kpm, *tmp;
+	int ret = -ENOENT;
+
+	mutex_lock(&kpm_mutex);
+	list_for_each_entry_safe(kpm, tmp, &kpm_modules, list) {
+		if (strcmp(kpm->name, name) == 0) {
+			/* Make text section non-executable before unloading */
+			set_memory_nx((unsigned long)kpm->module_addr,
+				      kpm->module_size >> PAGE_SHIFT);
+
+			list_del(&kpm->list);
+			vfree(kpm->module_addr);
+			kfree(kpm->reloc_addr);
+			kfree(kpm);
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&kpm_mutex);
+
+	if (ret == 0)
+		pr_info("KPM: Unregistered module '%s'\n", name);
+	else
+		pr_err("KPM: Module '%s' not found\n", name);
+	return ret;
+}
+EXPORT_SYMBOL(kpm_unregister);
+
+static int __init kpm_init(void)
+{
+	pr_info("KPM: KernelPatch Module support initialized\n");
+	return 0;
+}
+
+static void __exit kpm_exit(void)
+{
+	struct kpm_module *kpm, *tmp;
+
+	mutex_lock(&kpm_mutex);
+	list_for_each_entry_safe(kpm, tmp, &kpm_modules, list) {
+		list_del(&kpm->list);
+		set_memory_nx((unsigned long)kpm->module_addr,
+			      kpm->module_size >> PAGE_SHIFT);
+		vfree(kpm->module_addr);
+		kfree(kpm->reloc_addr);
+		kfree(kpm);
+	}
+	mutex_unlock(&kpm_mutex);
+	pr_info("KPM: KernelPatch Module support exited\n");
+}
+
+module_init(kpm_init);
+module_exit(kpm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("KernelPatch Module Support");
+MODULE_AUTHOR("Kernel Patch Team");
diff --git a/kernel/kpm/kpm.h b/kernel/kpm/kpm.h
new file mode 100644
index 0000000..XXXXXXX
--- /dev/null
+++ b/kernel/kpm/kpm.h
@@ -0,0 +1,23 @@
+#ifndef __KERNEL_KPM_H
+#define __KERNEL_KPM_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+
+/**
+ * kpm_register - Register and load a KPM module
+ * @name: Name of the KPM module
+ * @data: ELF binary data of the module
+ * @size: Size of the ELF binary data
+ *
+ * Returns 0 on success, negative error code on failure.
+ */
+int kpm_register(const char *name, void *data, size_t size);
+
+/**
+ * kpm_unregister - Unload and unregister a KPM module
+ * @name: Name of the KPM module to unregister
+ *
+ * Returns 0 on success, negative error code on failure.
+ */
+int kpm_unregister(const char *name);
+
+#endif /* __KERNEL_KPM_H */
